// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Process = require("process");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Grammar$Ipa = require("./Grammar.bs.js");
var Caml_splice_call = require("bs-platform/lib/js/caml_splice_call.js");

((require('isomorphic-fetch')));

var path_in = Caml_array.caml_array_get(Process.argv, 2);

var file_in = Fs.readFileSync(path_in, "utf8");

var rex = (/\n+/g);

function url_or_word(word) {
  var parsed = word.replace((/\s+/g), "-").toLowerCase();
  return "https://dictionary.cambridge.org/dictionary/english/" + (String(parsed) + "");
}

function ipa_of_word(word) {
  return fetch(url_or_word(word)).then((function (prim) {
                      return prim.text();
                    })).then((function (html) {
                    var rex = (/<span class="ipa dipa lpr-2 lpl-1">(\S+)<\/span>\/<\/span>/g);
                    var match = rex.exec(html);
                    return Promise.resolve(match !== null ? match : /* array */[]);
                  })).then((function (ms) {
                  return Promise.resolve(Belt_Array.get(Belt_Array.map(ms, (function (x) {
                                        if (x == null) {
                                          return "";
                                        } else {
                                          return x;
                                        }
                                      })), 1));
                })).then((function (w) {
                return Promise.resolve(w !== undefined ? w.trim() : word);
              }));
}

Promise.all(Belt_Array.map(file_in.split((/\s+/g)), (function (x) {
              if (x !== undefined) {
                var match = Grammar$Ipa.grammarify(x);
                var suffix = match[1];
                return ipa_of_word(match[0]).then((function (ipa) {
                              return Promise.resolve(ipa + suffix);
                            }));
              } else {
                return Promise.resolve("");
              }
            }))).then((function (ws) {
        return Promise.resolve((Caml_splice_call.spliceApply(console.log, [ws]), /* () */0));
      }));

exports.path_in = path_in;
exports.file_in = file_in;
exports.rex = rex;
exports.url_or_word = url_or_word;
exports.ipa_of_word = ipa_of_word;
/*  Not a pure module */
